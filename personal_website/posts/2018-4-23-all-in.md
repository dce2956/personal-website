---
title: All in 
tags: Elixir
description: Ughhh, I hate that I'm writing this post. I hate these things usually. But, I've found that I've had to repeat myself in long emails a couple times recently, and I hate that even more, so when that happens I write a blog post that I can just share the link to for future times when I need this thing.
date: 2018-5-28 00:18:00
---

**Disclaimer:**
Ughhh, I hate that I'm writing this post. I hate these things usually. But, I've
found that I've had to repeat myself in long emails a couple times recently, and
I hate that even more, so when that happens I write a blog post that I can just
have on hand for future times when I need this thing.

I'm going all in on Elixir. Well, I've been pretty much all in on it for a
couple months now, but now I'm just making it super public. This means that in
the future (or until I change my mind for some reason - I do reserve that right)
I'm only looking for Elixir work, I'm only going to be doing Elixir open source
work, and I'm only going to be speaking at Elixir (or broader FP) conferences.
I'll probably only be writing about Elixir stuff, too.

## Why Elixir?

Honestly, I don't really know. I've been writing Elixir for nearly 3 years now,
and seriously for almost 2 years. It's a little hard to put my finger on, but it
just really resonates with me. But here's an attempt at specifics.

To me, it's the perfect language. It fits the way I like to develop, and the way
I think. I'm fast writing Elixir, so I get a lot of stuff done really quickly -
and that has a lot of value for me.

My tests run really, really fast. This seems like such a small thing, but to me
it matters. Entire test suites run in seconds and not minutes. Sure, the
application performance is nice, but the _development_ performance is a big
reason why I find myself getting more done, faster, in Elixir.

I like the simplicity of the language (and of FP in general). There's no memorizing 30 different
design patterns and 50 code smells - and knowing when to use all that knowledge - it's (mostly) just functions and data. The choices
you need to make are more about naming than about architecture. You're spending
more time in the domain of your problem and less time in the domain of your
code, which I think is helpful.

It's generally a pretty easy-to-understand language. No searching down the call
stack of that one instance that got `instance_exec`'d to do the thing you
needed. Ruby is a very sharp tool, but most of the time I see people cutting
themselves pretty badly with those tools. Elixir isn't as sharp, but in 2 years
of serious use I haven't seen that as a problem even once. I don't find the
simplicity of the language and paradigm to be holding me back from solving any
problems that I've needed to solve.

There's generally less to keep in your head at any given time because of
referential transparency. Sure, distributed
systems on a large scale are always kind of tricky, but even those are much
simpler with Elixir.

The community has grown into something really great in the last few years. There
are leaders in the community that are helpful and available to mentor those who
want to know more. Maybe I'm a unique case, but I've been personally helped
dozens of times by people on the core team when I needed that help. And they're
all super nice about it, too.

The error messages are really nice, and the core team puts a lot of time into
making them better. This really matters.

## Why now?

A couple reasons. First off, without even really trying, I've found that most of
the work that's been coming to me has been Elixir in the last 6 months. Two
years ago most people were asking me to help with Ruby projects, and now it's
Elixir. I can't say why that is, but I feel comfortable that I'm not putting my
livelihood in jeopardy by making this choice.

Second, there is now enough of a market for developers out there. Even a year
ago I kind of felt bad if I was approached to write an application for a company
and I wanted to use Elixir. They would have had a kind of hard time either
training someone to maintain it, or finding someone to hire. That's not such a
problem now.

The ecosystem of packages has matured to a point where you can solve pretty much
anything you need to solve with a really well-done existing solution. You don't
really need to write stuff from scratch anymore. We haven't reached the point of
JavaScript where there are 20 solutions for every problem, but we have one, and
that's good enough for me.

Also, in the last year I've found myself getting a little worn down. I'm really
busy with two young kids at home and a wife who's a successful opera singer. I
mean, right now we're half way through 12 weeks on the road for gigs for my
wife. I just couldn't do everything that I wanted to do in the Ruby world and
everything I wanted to do in the Elixir world, while also having time for work
and family. And so I had to choose. It wasn't an easy choice, but I felt that
it's the right choice for me.

## So you really won't be doing Ruby anymore?

Writing Elixir makes me happy. Paying off my family's student loans would also
make me happy. The language you use is one part of happiness in work, but
it's not everything. Ruby is still a great language - and there are many people
who feel about Ruby the same way I feel about Elixir. For the right opportunity
I'd totally consider writing in any language! And if we had a different life,
where I had more time to devote to work and programming as a hobby, I wouldn't
even have to make this decision. But that's not my reality.

And I don't ever see myself separating completely from the Ruby community. It's
just too full of really great people for me to walk away. The Ruby community was
the thing that really made me love the language in the first place, and that's
what will make it impossible to leave completely. I just might not be seeing you
all at conferences anymore, or at least for a good long while.
